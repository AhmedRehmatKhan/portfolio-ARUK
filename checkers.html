<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>AR Checkers - Play Online</title>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
  }
  .header {
    text-align: center;
    margin-bottom: 30px;
    color: white;
  }
  .header h1 {
    font-size: 3rem;
    margin-bottom: 10px;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
  }
  .header p {
    font-size: 1.2rem;
    opacity: 0.9;
  }
  .game-container {
    background: white;
    border-radius: 20px;
    padding: 30px;
    box-shadow: 0 20px 40px rgba(0,0,0,0.1);
    max-width: 900px;
    width: 100%;
  }
  .game-modes {
    display: flex;
    gap: 20px;
    margin-bottom: 30px;
    justify-content: center;
    flex-wrap: wrap;
  }
  .mode-btn {
    padding: 15px 30px;
    border: none;
    border-radius: 10px;
    font-size: 1.1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    min-width: 150px;
  }
  .mode-btn.active {
    background: #667eea;
    color: white;
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
  }
  .mode-btn:not(.active) {
    background: #f8f9fa;
    color: #333;
    border: 2px solid #e9ecef;
  }
  .mode-btn:not(.active):hover {
    background: #e9ecef;
    transform: translateY(-1px);
  }
  .connection-panel {
    background: #f8f9f9;
    border-radius: 15px;
    padding: 25px;
    margin-bottom: 30px;
    text-align: center;
  }
  .connection-panel.hidden {
    display: none;
  }
  .connection-options {
    display: flex;
    gap: 20px;
    justify-content: center;
    margin: 20px 0;
    flex-wrap: wrap;
  }
  .connection-card {
    background: white;
    border-radius: 10px;
    padding: 20px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    min-width: 200px;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 2px solid transparent;
  }
  .connection-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 16px rgba(0,0,0,0.15);
  }
  .connection-card.active {
    border-color: #667eea;
    background: #f0f4ff;
  }
  .room-input {
    display: flex;
    gap: 10px;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
    margin-top: 15px;
  }
  .room-input input {
    padding: 12px 20px;
    border: 2px solid #ddd;
    border-radius: 8px;
    font-size: 1rem;
    min-width: 200px;
    text-transform: uppercase;
  }
  .room-input button {
    padding: 12px 25px;
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 1rem;
    cursor: pointer;
    transition: all 0.3s ease;
    font-weight: 600;
  }
  .join-btn {
    background: #28a745;
  }
  .join-btn:hover {
    background: #218838;
  }
  .create-btn {
    background: #007bff;
  }
  .create-btn:hover {
    background: #0056b3;
  }
  .game-status {
    text-align: center;
    margin-bottom: 25px;
    padding: 20px;
    background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
    border-radius: 15px;
    border-left: 5px solid #2196f3;
  }
  .game-status h3 {
    color: #1976d2;
    margin-bottom: 8px;
    font-size: 1.4rem;
  }
  .game-status p {
    color: #666;
    font-size: 1.1rem;
  }
  .game-layout {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    gap: 30px;
    align-items: start;
  }
  .player-panel {
    background: #f8f9f9;
    border-radius: 15px;
    padding: 20px;
    text-align: center;
    transition: all 0.3s ease;
  }
  .player-panel.active {
    background: linear-gradient(135deg, #e3f2fd, #f0f4ff);
    border: 2px solid #2196f3;
    transform: scale(1.02);
  }
  .player-panel h4 {
    margin-bottom: 15px;
    color: #333;
    font-size: 1.2rem;
  }
  .player-stats {
    display: flex;
    justify-content: space-between;
    margin-bottom: 15px;
  }
  .stat-item {
    text-align: center;
  }
  .stat-value {
    font-size: 1.5rem;
    font-weight: bold;
    color: #2196f3;
  }
  .stat-label {
    font-size: 0.9rem;
    color: #666;
  }
  .captured-pieces {
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
    justify-content: center;
    min-height: 40px;
    padding: 10px;
    background: white;
    border-radius: 8px;
    margin-top: 10px;
  }
  .captured-piece {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    border: 2px solid #333;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }
  .board-container {
    display: flex;
    justify-content: center;
    position: relative;
  }
  .checkers-board {
    display: grid;
    grid-template-columns: repeat(8, 65px);
    grid-template-rows: repeat(8, 65px);
    gap: 2px;
    background: #8B4513;
    padding: 15px;
    border-radius: 15px;
    box-shadow: 0 15px 30px rgba(0,0,0,0.3);
    position: relative;
  }
  .board-coordinates {
    position: absolute;
    color: #8B4513;
    font-weight: bold;
    font-size: 0.9rem;
  }
  .coord-numbers {
    left: -25px;
    top: 15px;
    display: flex;
    flex-direction: column;
    height: calc(8 * 67px);
    justify-content: space-around;
    align-items: center;
  }
  .coord-letters {
    bottom: -25px;
    left: 15px;
    display: flex;
    width: calc(8 * 67px);
    justify-content: space-around;
    align-items: center;
  }
  .square {
    width: 65px;
    height: 65px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    position: relative;
    transition: all 0.2s ease;
  }
  .square.light {
    background: #F5DEB3;
  }
  .square.dark {
    background: #8B4513;
  }
  .square.highlighted {
    background: #FFD700 !important;
    box-shadow: inset 0 0 15px rgba(255, 215, 0, 0.8);
    animation: pulse 1s infinite;
  }
  .square.possible-move {
    background: #90EE90 !important;
    box-shadow: inset 0 0 15px rgba(144, 238, 144, 0.8);
  }
  .square.last-move {
    background: #FFA500 !important;
    box-shadow: inset 0 0 10px rgba(255, 165, 0, 0.6);
  }
  @keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
  }
  .piece {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    border: 3px solid #333;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  }
  .piece.red {
    background: radial-gradient(circle at 30% 30%, #ff6b6b, #dc3545);
  }
  .piece.black {
    background: radial-gradient(circle at 30% 30%, #495057, #212529);
  }
  .piece.king::after {
    content: '‚ôî';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: gold;
    font-size: 24px;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
  }
  .piece:hover {
    transform: scale(1.1);
    box-shadow: 0 6px 12px rgba(0,0,0,0.4);
  }
  .piece.selected {
    transform: scale(1.2);
    box-shadow: 0 0 25px rgba(255, 215, 0, 0.9);
    animation: selectedPulse 0.8s infinite;
  }
  @keyframes selectedPulse {
    0%, 100% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.9); }
    50% { box-shadow: 0 0 35px rgba(255, 215, 0, 1); }
  }
  .move-history {
    background: white;
    border-radius: 10px;
    padding: 15px;
    margin-top: 20px;
    max-height: 200px;
    overflow-y: auto;
  }
  .move-history h5 {
    margin-bottom: 10px;
    color: #333;
  }
  .move-item {
    padding: 5px 10px;
    margin: 2px 0;
    background: #f8f9f9;
    border-radius: 5px;
    font-size: 0.9rem;
  }
  .controls {
    display: flex;
    gap: 15px;
    justify-content: center;
    margin-top: 30px;
    flex-wrap: wrap;
  }
  .control-btn {
    padding: 15px 30px;
    border: none;
    border-radius: 10px;
    font-size: 1.1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    min-width: 140px;
  }
  .reset-btn {
    background: #dc3545;
    color: white;
  }
  .reset-btn:hover {
    background: #c82333;
    transform: translateY(-2px);
  }
  /* Additional responsiveness styles omitted for brevity */
</style>
</head>
<body>
<div class="header">
  <h1>üèÅ Buddy Checkers</h1>
  <p>Challenge friends online or test your skills against our AI!</p>
</div>

<div class="game-container">
  <div class="game-modes">
    <button class="mode-btn active" onclick="setGameMode('friend')">üë• Play with Friend</button>
    <button class="mode-btn" onclick="setGameMode('bot')">ü§ñ Play with Bot</button>
  </div>

  <div class="connection-panel" id="connectionPanel">
    <h3>üîó Connect with Your Friend</h3>
    <p>Choose how you want to connect and play together!</p>
    <div class="connection-options">
      <div class="connection-card active" onclick="selectConnectionType('create')">
        <h4>üéØ Create Room</h4>
        <p>Start a new game and invite a friend</p>
      </div>
      <div class="connection-card" onclick="selectConnectionType('join')">
        <h4>üö™ Join Room</h4>
        <p>Enter a friend's room code</p>
      </div>
    </div>
    <div class="room-input">
      <input type="text" id="roomCode" placeholder="Enter room code (e.g., GAME123)" maxlength="10">
      <button class="join-btn" onclick="joinRoom()">Join Room</button>
      <button class="create-btn" onclick="createRoom()">Create New Room</button>
    </div>
    <div id="roomStatus" style="margin-top: 15px; font-weight: 600;"></div>
    <div id="shareSection" style="display: none; margin-top: 15px; padding: 15px; background: #e8f5e8; border-radius: 10px;">
      <h4 style="margin-bottom: 10px; color: #155724;">üì§ Share with Friend</h4>
      <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap; justify-content: center;">
        <input type="text" id="shareLink" readonly style="flex: 1; min-width: 250px; padding: 10px; border: 2px solid #28a745; border-radius: 5px; background: white; font-family: monospace;">
        <button onclick="copyShareLink()" style="padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">üìã Copy Link</button>
        <button onclick="shareViaEmail()" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">üìß Email</button>
      </div>
      <p style="margin-top: 8px; font-size: 0.9rem; color: #666; text-align: center;">Send this link to your friend so they can join instantly!</p>
    </div>
    <div id="connectionStatus" class="connection-status status-disconnected">
      <span>‚ö´</span> Not Connected
    </div>
  </div>

  <div class="difficulty-selector" id="difficultySelector" style="display: none;">
    <label for="botDifficulty">ü§ñ Bot Difficulty: </label>
    <select id="botDifficulty" onchange="setBotDifficulty()">
      <option value="easy">Easy - Random moves</option>
      <option value="medium" selected>Medium - Smart moves</option>
      <option value="hard">Hard - Strategic play</option>
    </select>
  </div>

  <div class="game-status">
    <h3 id="gameTitle">üéÆ Ready to Play!</h3>
    <p id="gameMessage">Choose your game mode and start playing!</p>
  </div>

  <div class="game-layout">
    <div class="player-panel active" id="player1Panel">
      <h4>üî¥ Player 1 (Red)</h4>
      <div class="player-stats">
        <div class="stat-item">
          <div class="stat-value" id="redCount">12</div>
          <div class="stat-label">Pieces</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="redKings">0</div>
          <div class="stat-label">Kings</div>
        </div>
      </div>
      <div class="captured-pieces" id="redCaptured"></div>
      <div class="move-history" id="redHistory">
        <h5>Recent Moves</h5>
        <div id="redMoves"></div>
      </div>
    </div>
    <div class="board-container">
      <div class="board-coordinates coord-numbers">
        <div>8</div><div>7</div><div>6</div><div>5</div><div>4</div><div>3</div><div>2</div><div>1</div>
      </div>
      <div class="board-coordinates coord-letters">
        <div>A</div><div>B</div><div>C</div><div>D</div><div>E</div><div>F</div><div>G</div><div>H</div>
      </div>
      <div class="checkers-board" id="board"></div>
    </div>
    <div class="player-panel" id="player2Panel">
      <h4 id="player2Title">‚ö´ Player 2 (Black)</h4>
      <div class="player-stats">
        <div class="stat-item">
          <div class="stat-value" id="blackCount">12</div>
          <div class="stat-label">Pieces</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="blackKings">0</div>
          <div class="stat-label">Kings</div>
        </div>
      </div>
      <div class="captured-pieces" id="blackCaptured"></div>
      <div class="move-history" id="blackHistory">
        <h5>Recent Moves</h5>
        <div id="blackMoves"></div>
      </div>
    </div>
  </div>
  <div class="controls">
    <button class="control-btn reset-btn" onclick="resetGame()">üîÑ New Game</button>
  </div>
</div>
<script>
  class CheckersGame {
    constructor() {
      this.board = [];
      this.currentPlayer = 'red';
      this.selectedPiece = null;
      this.gameMode = 'friend';
      this.botDifficulty = 'medium';
      this.roomCode = null;
      this.isConnected = false;
      this.connectionType = 'create';
      this.redPieces = 12;
      this.blackPieces = 12;
      this.redKings = 0;
      this.blackKings = 0;
      this.gameActive = true;
      this.moveHistory = [];
      this.lastMove = null;
      this.initializeBoard();
      this.renderBoard();
      this.updateUI();
    }
    initializeBoard() {
      this.board = Array(8).fill().map(() => Array(8).fill(null));
      for (let row = 5; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          if ((row + col) % 2 === 1) {
            this.board[row][col] = { color: 'red', king: false };
          }
        }
      }
      for (let row = 0; row < 3; row++) {
        for (let col = 0; col < 8; col++) {
          if ((row + col) % 2 === 1) {
            this.board[row][col] = { color: 'black', king: false };
          }
        }
      }
    }
    renderBoard() {
      const boardElement = document.getElementById('board');
      boardElement.innerHTML = '';
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          const square = document.createElement('div');
          square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
          square.dataset.row = row;
          square.dataset.col = col;
          const piece = this.board[row][col];
          if (piece) {
            const pieceDiv = document.createElement('div');
            pieceDiv.className = `piece ${piece.color} ${piece.king ? 'king' : ''}`;
            square.appendChild(pieceDiv);
          }
          square.addEventListener('click', () => this.handleSquareClick(row, col));
          boardElement.appendChild(square);
        }
      }
    }
    handleSquareClick(row, col) {
      if (!this.gameActive || (this.gameMode === 'bot' && this.currentPlayer === 'black')) return;
      const piece = this.board[row][col];
      if (this.selectedPiece) {
        const { row: fromRow, col: fromCol } = this.selectedPiece;
        if (fromRow === row && fromCol === col) {
          this.clearSelection();
          this.updateUI();
          return;
        }
        if (this.isValidMove(fromRow, fromCol, row, col)) {
          const wasJump = Math.abs(row - fromRow) === 2;
          this.makeMove(fromRow, fromCol, row, col);
          if (wasJump && this.getJumpMoves(row, col).length > 0) {
            this.selectPiece(row, col);
            this.updateUI();
            this.updateGameMessage('Multi-jump! Continue capturing.');
            return;
          }
          this.clearSelection();
          this.switchPlayer();
          if (this.gameMode === 'bot' && this.currentPlayer === 'black' && this.gameActive) {
            setTimeout(() => this.performBotMove(), 1200);
          }
        } else {
          this.clearSelection();
          if (piece && piece.color === this.currentPlayer) {
            this.selectPiece(row, col);
            this.updateUI();
          }
        }
      } else {
        if (piece && piece.color === this.currentPlayer) {
          this.selectPiece(row, col);
          this.updateUI();
        }
      }
    }
    selectPiece(row, col) {
      this.selectedPiece = { row, col };
      this.highlightPossibleMoves(row, col);
      this.renderBoard();
      const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
      square.classList.add('highlighted');
      square.querySelector('.piece').classList.add('selected');
    }
    highlightPossibleMoves(row, col) {
      const moves = this.getPossibleMoves(row, col);
      moves.forEach(move => {
        const square = document.querySelector(`[data-row="${move.row}"][data-col="${move.col}"]`);
        square.classList.add('possible-move');
      });
    }
    getPossibleMoves(row, col) {
      const piece = this.board[row][col];
      if (!piece) return [];
      const forcedJumps = this.getForcedJumps(this.currentPlayer);
      if (forcedJumps.some(j => j.fromRow === row && j.fromCol === col)) {
        return this.getJumpMoves(row, col);
      }
      const moves = [];
      const directions = piece.king ? 
        [[-1, -1], [-1, 1], [1, -1], [1, 1]] :
        (piece.color === 'red' ? [[-1, -1], [-1, 1]] : [[1, -1], [1, 1]]);
      directions.forEach(([dRow, dCol]) => {
        const nRow = row + dRow;
        const nCol = col + dCol;
        if (this.isValidMove(row, col, nRow, nCol)) {
          moves.push({ row: nRow, col: nCol });
        }
        const jumpRow = row + dRow * 2;
        const jumpCol = col + dCol * 2;
        if (this.isValidMove(row, col, jumpRow, jumpCol)) {
          moves.push({ row: jumpRow, col: jumpCol });
        }
      });
      return moves;
    }
    getJumpMoves(row, col) {
      const piece = this.board[row][col];
      if (!piece) return [];
      const moves = [];
      const directions = piece.king ? 
        [[-1, -1], [-1, 1], [1, -1], [1, 1]] :
        (piece.color === 'red' ? [[-1, -1], [-1, 1]] : [[1, -1], [1, 1]]);
      directions.forEach(([dRow, dCol]) => {
        const jumpRow = row + dRow * 2;
        const jumpCol = col + dCol * 2;
        if (this.isValidMove(row, col, jumpRow, jumpCol)) {
          moves.push({ row: jumpRow, col: jumpCol });
        }
      });
      return moves;
    }
    getForcedJumps(color) {
      const jumps = [];
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const piece = this.board[r][c];
          if (piece && piece.color === color) {
            const jumpMoves = this.getJumpMoves(r, c);
            jumpMoves.forEach(move => {
              jumps.push({ fromRow: r, fromCol: c, toRow: move.row, toCol: move.col });
            });
          }
        }
      }
      return jumps;
    }
    isValidMove(fromRow, fromCol, toRow, toCol) {
      if (toRow < 0 || toRow >= 8 || toCol < 0 || toCol >= 8) return false;
      if (this.board[toRow][toCol]) return false;
      if ((toRow + toCol) % 2 === 0) return false; // only dark squares
      const piece = this.board[fromRow][fromCol];
      if (!piece) return false;
      const rowDiff = toRow - fromRow;
      const colDiff = toCol - fromCol;
      if (Math.abs(rowDiff) === 1 && Math.abs(colDiff) === 1) {
        if (piece.king) return true;
        if (piece.color === 'red' && rowDiff < 0) return true;
        if (piece.color === 'black' && rowDiff > 0) return true;
        return false;
      }
      if (Math.abs(rowDiff) === 2 && Math.abs(colDiff) === 2) {
        const midRow = fromRow + rowDiff / 2;
        const midCol = fromCol + colDiff / 2;
        const middlePiece = this.board[midRow][midCol];
        if (middlePiece && middlePiece.color !== piece.color) {
          if (piece.king) return true;
          if (piece.color === 'red' && rowDiff < 0) return true;
          if (piece.color === 'black' && rowDiff > 0) return true;
        }
      }
      return false;
    }
    makeMove(fromRow, fromCol, toRow, toCol) {
      const piece = this.board[fromRow][fromCol];
      this.board[toRow][toCol] = piece;
      this.board[fromRow][fromCol] = null;
      let captured = null;
      const rowDiff = toRow - fromRow;
      const colDiff = toCol - fromCol;
      if (Math.abs(rowDiff) === 2) {
        const midRow = fromRow + rowDiff / 2;
        const midCol = fromCol + colDiff / 2;
        captured = this.board[midRow][midCol];
        if (captured) {
          this.board[midRow][midCol] = null;
          this.addCapturedPiece(captured.color);
          if (captured.color === 'red') {
            this.redPieces--;
            if (captured.king) this.redKings--;
          } else {
            this.blackPieces--;
            if (captured.king) this.blackKings--;
          }
        }
      }
      // Promotion to king
      if (piece && !piece.king && ((piece.color === 'red' && toRow === 0) || (piece.color === 'black' && toRow === 7))) {
        piece.king = true;
        if (piece.color === 'red') this.redKings++;
        else this.blackKings++;
      }
      this.lastMove = { fromRow, fromCol, toRow, toCol };
      this.addMoveToHistory(fromRow, fromCol, toRow, toCol, captured);
      this.updateUI();
      this.checkGameEnd();
    }
    switchPlayer() {
      this.currentPlayer = this.currentPlayer === 'red' ? 'black' : 'red';
      this.updateUI();
    }
    updateGameMessage(msg) {
      document.getElementById('gameMessage').textContent = msg;
    }
    addMoveToHistory(fromR, fromC, toR, toC, captured) {
      const from = String.fromCharCode(65 + fromC) + (8 - fromR);
      const to = String.fromCharCode(65 + toC) + (8 - toR);
      let moveText = `${from} ‚Üí ${to}`;
      if (captured) moveText += ' (captured)';
      this.moveHistory.push({ player: this.currentPlayer, text: moveText });
      this.updateMoveHistory();
    }
    updateMoveHistory() {
      const redMoves = document.getElementById('redMoves');
      const blackMoves = document.getElementById('blackMoves');
      redMoves.innerHTML = '';
      blackMoves.innerHTML = '';
      this.moveHistory.forEach(move => {
        const div = document.createElement('div');
        div.className = 'move-item';
        div.textContent = move.text;
        if (move.player === 'red') redMoves.appendChild(div);
        else blackMoves.appendChild(div);
      });
    }
    addCapturedPiece(color) {
      const container = color === 'red' ? document.getElementById('blackCaptured') : document.getElementById('redCaptured');
      const pieceDiv = document.createElement('div');
      pieceDiv.className = `captured-piece ${color}`;
      pieceDiv.style.background = color === 'red' ? 'radial-gradient(circle at 30% 30%, #ff6b6b, #dc3545)' : 'radial-gradient(circle at 30% 30%, #495057, #212529)';
      container.appendChild(pieceDiv);
    }
    performBotMove() {
      // Simplified random move for bot, can be replaced with AI logic
      const moves = this.getAllPossibleMoves('black');
      if (moves.length === 0) {
        this.endGame('red');
        return;
      }
      const move = moves[Math.floor(Math.random() * moves.length)];
      const wasJump = Math.abs(move.toRow - move.fromRow) === 2;
      this.makeMove(move.fromRow, move.fromCol, move.toRow, move.toCol);
      this.renderBoard();
      if (wasJump && this.getJumpMoves(move.toRow, move.toCol).length > 0) {
        setTimeout(() => this.performBotMove(), 800);
        return;
      }
      this.switchPlayer();
    }
    getAllPossibleMoves(color) {
      const moves = [];
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const piece = this.board[r][c];
          if (piece && piece.color === color) {
            const pmoves = this.getPossibleMoves(r, c);
            pmoves.forEach(move => {
              moves.push({ fromRow: r, fromCol: c, toRow: move.row, toCol: move.col });
            });
          }
        }
      }
      return moves;
    }
    getPossibleMoves(row, col) {
      const moves = [];
      const piece = this.board[row][col];
      if (!piece) return [];
      const forcedJumps = this.getForcedJumps(this.currentPlayer);
      if (forcedJumps.some(j => j.fromRow === row && j.fromCol === col)) {
        return this.getJumpMoves(row, col);
      }
      const directions = piece.king ? [[-1, -1], [-1, 1], [1, -1], [1, 1]] : 
        (piece.color === 'red' ? [[-1, -1], [-1, 1]] : [[1, -1], [1, 1]]);
      directions.forEach(([dR, dC]) => {
        const nR = row + dR;
        const nC = col + dC;
        if (this.isValidMove(row, col, nR, nC)) {
          moves.push({ row: nR, col: nC });
        }
        const jumpR = row + dR * 2;
        const jumpC = col + dC * 2;
        if (this.isValidMove(row, col, jumpR, jumpC)) {
          moves.push({ row: jumpR, col: jumpC });
        }
      });
      return moves;
    }
    isValidMove(fromR, fromC, toR, toC) {
      if (toR < 0 || toR >= 8 || toC < 0 || toC >= 8) return false;
      if (this.board[toR][toC]) return false;
      if ((toR + toC) % 2 === 0) return false;
      const piece = this.board[fromR][fromC];
      if (!piece) return false;
      const dr = toR - fromR;
      const dc = toC - fromC;
      if (Math.abs(dr) === 1 && Math.abs(dc) === 1) {
        if (piece.king) return true;
        if (piece.color === 'red' && dr < 0) return true;
        if (piece.color === 'black' && dr > 0) return true;
        return false;
      }
      if (Math.abs(dr) === 2 && Math.abs(dc) === 2) {
        const midR = fromR + dr / 2;
        const midC = fromC + dc / 2;
        const middle = this.board[midR][midC];
        if (middle && middle.color !== piece.color) {
          if (piece.king) return true;
          if (piece.color === 'red' && dr < 0) return true;
          if (piece.color === 'black' && dr > 0) return true;
        }
      }
      return false;
    }
    makeMove(fromR, fromC, toR, toC) {
      const piece = this.board[fromR][fromC];
      this.board[toR][toC] = piece;
      this.board[fromR][fromC] = null;
      // Handle captures
      if (Math.abs(toR - fromR) === 2) {
        const midR = (fromR + toR) / 2;
        const midC = (fromC + toC) / 2;
        const captured = this.board[midR][midC];
        if (captured) {
          this.board[midR][midC] = null;
          this.addCapturedPiece(captured.color);
          if (captured.color === 'red') {
            this.redPieces--;
            if (captured.king) this.redKings--;
          } else {
            this.blackPieces--;
            if (captured.king) this.blackKings--;
          }
        }
      }
      // Promotion
      if (piece) {
        if (piece.color === 'red' && toR === 0 && !piece.king) {
          piece.king = true;
          this.redKings++;
        } else if (piece.color === 'black' && toR === 7 && !piece.king) {
          piece.king = true;
          this.blackKings++;
        }
      }
      this.lastMove = { fromRow: fromR, fromCol: fromC, toRow: toR, toCol: toC };
      this.addMoveToHistory(fromR, fromC, toR, toC, null);
      this.updateUI();
      this.checkGameEnd();
    }
    switchPlayer() {
      this.currentPlayer = this.currentPlayer === 'red' ? 'black' : 'red';
      this.updateUI();
    }
    updateUI() {
      // Update counts
      document.getElementById('redCount').textContent = this.redPieces;
      document.getElementById('blackCount').textContent = this.blackPieces;
      document.getElementById('redKings').textContent = this.redKings;
      document.getElementById('blackKings').textContent = this.blackKings;
      
      // Update active panel
      const redPanel = document.getElementById('player1Panel');
      const blackPanel = document.getElementById('player2Panel');
      if (this.currentPlayer === 'red') {
        redPanel.classList.add('active');
        blackPanel.classList.remove('active');
      } else {
        redPanel.classList.remove('active');
        blackPanel.classList.add('active');
      }
      
      // Update game message
      const title = document.getElementById('gameTitle');
      const msg = document.getElementById('gameMessage');
      if (this.gameActive) {
        title.textContent = `${this.currentPlayer === 'red' ? 'üî¥ Red' : '‚ö´ Black'}'s Turn`;
        if (this.currentPlayer === 'red') {
          msg.textContent = 'Your move! Click a piece to move.';
        } else {
          msg.textContent = 'Bot is thinking...';
        }
      } else {
        title.textContent = 'Game Over!';
        msg.textContent = '';
      }
    }
    checkGameEnd() {
      if (this.redPieces === 0 || this.blackPieces === 0) {
        this.endGame(this.redPieces > 0 ? 'red' : 'black');
        return;
      }
      const moves = this.getAllPossibleMoves(this.currentPlayer);
      if (moves.length === 0) {
        this.endGame(this.currentPlayer === 'red' ? 'black' : 'red');
      }
    }
    endGame(winner) {
      this.gameActive = false;
      document.getElementById('gameTitle').textContent = `üéâ ${winner.charAt(0).toUpperCase() + winner.slice(1)} Wins!`;
      document.getElementById('gameMessage').textContent = 'Click "New Game" to play again!';
    }
    reset() {
      this.initializeBoard();
      this.renderBoard();
      this.currentPlayer = 'red';
      this.selectedPiece = null;
      this.redPieces = 12;
      this.blackPieces = 12;
      this.redKings = 0;
      this.blackKings = 0;
      this.gameActive = true;
      this.moveHistory = [];
      this.lastMove = null;
      this.updateUI();
    }
  }

  const game = new CheckersGame();

  function setGameMode(mode) {
    game.gameMode = mode;
    document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
    event.target.classList.add('active');
    document.getElementById('connectionPanel').classList.toggle('hidden', mode !== 'friend');
    document.getElementById('difficultySelector').style.display = mode === 'bot' ? 'block' : 'none';
    if (mode === 'friend') {
      resetGame();
    } else if (mode === 'bot') {
      resetGame();
    }
  }

  function selectConnectionType(type) {
    game.connectionType = type;
    document.querySelectorAll('.connection-card').forEach(card => card.classList.remove('active'));
    event.target.classList.add('active');
    if (type === 'create') {
      document.getElementById('roomCode').placeholder = 'Room will be generated...';
      document.getElementById('roomCode').disabled = true;
    } else {
      document.getElementById('roomCode').placeholder = 'Enter room code (e.g., GAME123)';
      document.getElementById('roomCode').disabled = false;
    }
  }

  function createRoom() {
    const roomCode = 'ROOM' + Math.random().toString(36).substr(2, 4).toUpperCase();
    document.getElementById('roomCode').value = roomCode;
    document.getElementById('roomStatus').innerHTML = `
      <div style="color: #28a745;">‚úÖ Room Created Successfully!</div>
      <div style="margin-top: 8px;">Room Code: <strong>${roomCode}</strong></div>
      <div style="font-size: 0.9rem; color: #666; margin-top: 5px;">Use the share options below to invite your friend!</div>
    `;
    document.getElementById('shareSection').style.display = 'block';
    const shareLink = document.getElementById('shareLink');
    shareLink.value = window.location.origin + window.location.pathname + '?room=' + roomCode;
    updateConnectionStatus('waiting', 'Waiting for friend to join...');
    game.roomCode = roomCode;
    // Simulate connection
    setTimeout(() => {
      updateConnectionStatus('connected', `Connected to ${roomCode}`);
      game.isConnected = true;
    }, 3000);
  }

  function joinRoom() {
    const code = document.getElementById('roomCode').value.trim().toUpperCase();
    if (code.length < 4) {
      document.getElementById('roomStatus').innerHTML = `
        <div style="color: #dc3545;">‚ùå Please enter a valid room code</div>
      `;
      return;
    }
    document.getElementById('roomStatus').innerHTML = `
      <div style="color: #28a745;">‚úÖ Successfully Joined!</div>
      <div style="margin-top: 8px;">Connected to room: <strong>${code}</strong></div>
      <div style="font-size: 0.9rem; color: #666; margin-top: 5px;">You can now play with your friend!</div>
    `;
    updateConnectionStatus('connected', `Connected to ${code}`);
    game.roomCode = code;
    game.isConnected = true;
  }

  function updateConnectionStatus(status, message) {
    const statusEl = document.getElementById('connectionStatus');
    statusEl.className = `connection-status status-${status}`;
    const icons = { connected: 'üü¢', waiting: 'üü°', disconnected: '‚ö´' };
    statusEl.innerHTML = `<span>${icons[status]}</span> ${message}`;
  }

  function resetGame() {
    game.reset();
  }

  function copyShareLink() {
    const linkInput = document.getElementById('shareLink');
    linkInput.select();
    linkInput.setSelectionRange(0, 99999);
    try {
      document.execCommand('copy');
      alert('Link copied to clipboard!');
    } catch {
      alert('Please copy manually: ' + linkInput.value);
    }
  }

  function shareViaEmail() {
    const code = game.roomCode || 'N/A';
    const link = document.getElementById('shareLink').value;
    const subject = encodeURIComponent('Join my Checkers game!');
    const body = encodeURIComponent(`Hi! Join my checkers game.\n\nRoom Code: ${code}\nLink: ${link}\n\nLet's play!`);
    window.open(`mailto:?subject=${subject}&body=${body}`);
  }

  function checkUrlForRoom() {
    const params = new URLSearchParams(window.location.search);
    const room = params.get('room');
    if (room) {
      document.getElementById('roomCode').value = room.toUpperCase();
      selectConnectionType('join');
      document.getElementById('roomStatus').innerHTML = `
        <div style="color: #007bff;">üîó Room link detected!</div>
        <div style="margin-top: 8px;">Room Code: <strong>${room.toUpperCase()}</strong></div>
        <div style="font-size: 0.9rem; color: #666;">Click "Join Room" to connect!</div>
      `;
    }
  }

  window.addEventListener('DOMContentLoaded', () => {
    setGameMode('friend');
    selectConnectionType('create');
    checkUrlForRoom();
  });
</script>
<script>(function(){/* external script omitted for brevity */})();</script>
</body>
</html>




